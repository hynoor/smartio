#! python sdd.py

import os
import sys
import time
import mmap
import getopt


def do_io(file_path, rw, pattern, io_size, count, skip, step, direct, wait):
    if rw == 'read' or rw == 'r':
        openmode = os.O_RDONLY
    elif rw == 'write' or rw == 'w':
        openmode = os.O_RDWR
    if direct == 1:
        openmode |= os.O_DIRECT
    
    # use mmap make it page aligned
    buf = mmap.mmap(-1, io_size)
    buf.write(pattern)

    try:
	fd = os.open(file_path, openmode)
        stop = (io_size + step) * count
        step += io_size
        print("dbg: [%d, %d %d]" %(skip, stop, step))
        for pos in xrange(skip, stop, step):
            os.lseek(fd, pos, os.SEEK_CUR)
            if rw == 'write' or rw == 'w':
                os.write(fd, buf)
            elif rw == 'read' or rw == 'r':
                buf = os.read(fd, io_size)
                print("dbg: %s" % buf)
            elif rw == 'noop':
                pass
            print("dbg: %s (offset=%d, len=%d)" % (rw, pos, io_size))
            time.sleep(wait)
    except IOError as e:
        print("EORR: Failed to perform DirectIO with error: %s" % str(e))
    
    return fd


def usage():
    print("smartio - A smart, lite IO tool")
    print("smartio.py <OPTIONS>")
    OPT = "\n"
    OPT += "OPTIONs:\n"
    OPT += "h: print help\n"
    OPT += "--path   : Target file/block to be manipulated\n"
    OPT += "--rw     : Write or read, accepts values: 'w', 'r', 'write', 'read' and 'null'\n"
    OPT += "--iosize : Size of each IO to be performed\n"
    OPT += "--count  : Number of IO to be performed\n"
    OPT += "--skip   : The starting offset\n"
    OPT += "--step   : The offset interval between each IO\n"
    OPT += "--direct : If use direct IO, accepts '1' and '0'\n"
    OPT += "--lock   : If created Range lock before IO, accepts values 'exclusive', 'shared' and 'unlock'(verify on exclusive)\n"
    OPT += "--wait   : Duration of wait in between ech IO\n"
    OPT += "--hold   : Duration to hold after the completion of IO\n"

    print(OPT)

def stats():
    """ summarize the performance stats
    """
    return  #TBD


def convert_size(raw):
   return int(raw) #TBD
     

if __name__ == '__main__':
    """ main test
    """
    if len(sys.argv) == 0:
        useage()
        sys.exit(-1)
    # set default
    fp = None
    iosize = 512
    iopattern = '1' * iosize
    iocount = 1
    rw = 'read'
    wait = 0
    hold = 0
    step = 0
    skip = 0
    lock= 'shared'
    direct = 0
   
    try:
        opts, args = getopt.getopt(
                sys.argv[1:], 
                'h:', [
                          'help',
                          'path=', 
                          'rw=',
                          'iosize=',
                          'pattern=',
                          'count=', 
                          'wait=', 
                          'hold=', 
                          'lock=', 
                          'skip=', 
                          'step=', 
                          'direct=']
        )

    except getopt.GetoptError as e:
        # print help information and exit:
        usage()
        sys.exit("Wrong Input" % str(e))
                    
    for o, a in opts:
        if o in ('--path'):
            fp = a  
        elif o in ('--rw'):
            rw = a
        elif o in ('--iosize'):
            iosize=convert_size(a)
        elif o in ('--pattern'):
            iopattern = get_pattern(a)
        elif o in ('--rw'):
            rw = a
        elif o in ('--count'):
            iocount = int(a)
        elif o in ('--wait'):
            wait = int(a)
        elif o in ('--hold'):
            hold = int(a)
        elif o in ('--lock'):
            lock = a
        elif o in ('--skip'):
            skip = convert_size(a)
        elif o in ('--step'):
            step = convert_size(a)
        elif o in ('--direct'):
            direct = int(a)
        else:
            assert False, usage()

    myfd = do_io(fp, rw, iopattern, iosize, iocount, skip, step, direct, wait)
    stats()
    if hold != 0:
        print("I/O completed, holding for %d seconds" % hold)
        time.sleep(hold)
    else:
        print("Done")
    os.close(myfd)

