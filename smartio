#! python smartio

import os
import sys
import time
import mmap
import re
import getopt
import logging

gspent = 0
glocks = []
greadcnt = 0
gwritecnt = 0
platform = os.name

FORMAT = '%(asctime)-15s %(message)s'
logging.basicConfig(format=FORMAT)
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

if platform == 'posix':
    import fcntl
    import struct
    # mode : (open_mode, lock_type, operation_type)
    LOCK_MODES = {
        'exclusive'        : (fcntl.F_WRLCK, fcntl.F_SETLK),
        'exclusive_blk'    : (fcntl.F_WRLCK, fcntl.F_SETLKW),
        'shared'           : (fcntl.F_RDLCK, fcntl.F_SETLK),
        'unlock'           : (fcntl.F_UNLCK, fcntl.F_SETLK),
    }
elif platform == 'nt':
    import msvcrt
    LOCK_MODES = {
        'exclusive'        : (msvcrt.LK_NBLCK),
        'exclusive_blk'    : (msvcrt.LK_LOCK),
        'shared'           : (msvcrt.LK_NBRLCK),
        'unlock'           : (msvcrt.LK_UNLCK),
    }
else:
    sys.exit("Unsupported Platform!")


def timeit(method):
    def timed(*args, **kw):
        ts = time.time()
        result = method(*args, **kw)
        te = time.time()
        global gspent
        gspent = (te - ts) * 1000
        if 'log_time' in kw:
            name = kw.get('log_name', method.__name__.upper())
            kw['log_time'][name] = int(gspent)
        else:
            #logger.debug("%r  %2.2f ms' % (method.__name__, gspent))
            pass
        return result

    return timed


@timeit
def do_io(file_path, rw, pattern, io_size, count, skip, step, direct, lock, wait):
    global glocks
    global greadcnt
    global gwritecnt

    if rw in ['read', 'r', 'noop']:
        openmode = os.O_RDONLY
    elif rw == 'write' or rw == 'w':
        openmode = os.O_RDWR 
    elif rw == 'create' or rw == 'c':
        openmode = os.O_RDWR 
        openmode |= os.O_CREAT
    if direct == 1:
        openmode |= os.O_DIRECT
    # exclusive lock requires RDWR-ed fd
    if lock in ['exclusive']:
        openmode |= os.O_RDWR 

    if lock != 'noop':
        do_lock = posix_lock
    else:
        def do_lock(*args):
            pass
    if direct:
        # use mmap make it page aligned
        buf = mmap.mmap(-1, io_size)
        buf.write(pattern * (io_size//len(pattern)) + pattern[:io_size%len(pattern)])
    else:
        buf = pattern * (io_size//len(pattern)) + pattern[:io_size%len(pattern)]
    try:
        fd = os.open(file_path, openmode)
    except OSError as e:
        exit("[err]: open failed, %s" % str(e))
    stop = skip + (io_size + step) * count
    step += io_size
    logger.debug("[%d, %d %d]" %(skip, stop, step))
    for idx, pos in enumerate(xrange(skip, stop, step), 1):
        os.lseek(fd, pos, os.SEEK_SET)
        try:
            if rw in ['write', 'w', 'create', 'c']:
                do_lock(fd, lock, pos, io_size, None)
                os.write(fd, buf)
                gwritecnt += 1
            elif rw in ['read', 'r']:
                do_lock(fd, lock, pos, io_size, None)
                buf = os.read(fd, io_size)
                greadcnt += 1
            elif rw == 'noop':
                do_lock(fd, lock, pos, io_size, None)
                pass
            logger.debug("%s #%d (offset=%d, len=%d)" % (rw,idx, pos, io_size))
            time.sleep(wait)
        except IOError as e:
            logger.error("IO Eorr [offset=%d, len=%d]  failed  with error: %s" % (pos, io_size, str(e)))
            os.close(fd)

    return fd


def nt_lock(offset, length, mode):
    """ create NT lock
    """
    return 


def usage():
    print("\nsmartio - a smart and lite file protocol probing tool\n")
    print("smartio.py <OPTIONS>")
    OPT = "\n"
    OPT += "OPTIONs:\n\n"
    OPT += "    --path       : Target file/block to be manipulated\n"
    OPT += "    --rw         : Write or read, accepts values: create|c|write|w|read|r \n"
    OPT += "    --iosize     : Size of each IO to be performed\n"
    OPT += "    --count      : Number of IO to be performed\n"
    OPT += "    --skip       : The starting offset\n"
    OPT += "    --step       : The offset interval between each IO\n"
    OPT += "    --direct     : Indicate if use direct IO, accepts 0|1 \n"
    OPT += "    --lock       : Indicate if create range lock before IO, accepts value exclusive|shared|unlock\n"
    OPT += "    --wait       : Duration of wait in between each IO\n"
    OPT += "    --hold       : Duration to hold after the completion of IO\n"
    OPT += "    --debug      : If enable debugging logs \n"
    OPT += "    --stoponerr  : If stop on error\n\n"

    print(OPT)


def stats(fp, iosize, count):
    """ summarize the performance stats
    """
    stats = "\n[stats]\n"
    stats += "target      : %s\n"
    stats += "block size  : %d\n"
    stats += "write count : %d\n"
    stats += "read count  : %d\n"
    stats += "total size  : %d\n"
    stats += "lock count  : %d\n"
    stats += "io duration : %2.2f ms\n"
    logger.info(stats % (fp, iosize, gwritecnt, greadcnt, iosize*count, len(glocks), gspent))


def convert_size(rawsize):
    """ convert non-byte to byte
    param raw_size  : passed raw size
    return size     : size in byte
    """
    sm = re.search('^(\d+)(\w{1,2})?', str(rawsize))
    if sm:
        number = sm.group(1)
        if sm.group(2):
            unit = sm.group(2)
            if unit.upper() == 'B':
                return int(number)
            elif unit.upper() == 'K' or unit.upper() == 'KB':
                return int(number) * 1024
            elif unit.upper() == 'M' or unit.upper() == 'MB':
                return int(number) * 1024 ** 2
            elif unit.upper() == 'G' or unit.upper() == 'GB':
                return int(number) * 1024 ** 3
            elif unit.upper() == 'T' or unit.upper() == 'TB':
                return int(number) * 1024 ** 4
            elif unit.upper() == 'P' or unit.upper() == 'PB':
                return int(number) * 1024 ** 5
            else:
                sys.exit("ERR: Invalid unit: %s" % unit)
        else:
            return int(number)
    else:
        return rawsize


def posix_lock(fd, mode, offset, length, data):
    """ posix locks
    """
    global glocks
    lockdata = struct.pack('hhllhh', LOCK_MODES[mode][0], \
            0, offset, length, 0, 0)
    try:
        if data:
            if mode == 'exclusive_io' or mode == 'exclusive_blk_io':
                rv = fcntl.fcntl(fd, LOCK_MODES[mode][1], lockdata)
                # truncate extra content which exceeds end offest
                fh.write(data)
            elif mode == 'shared' or mode == 'unlock':
                # NOTE
                # the minimal size of kernel read is one page (4KB)
                # hence the read may failed if target bytes
                # which page was overlappped on other byte(s)
                # owned by other lockowners
                readdata = fh.read(len(self._data))
                if readdata != data:
                    logger.error("ERR: DMC! expect: %s | actual: %s" % (data, readdata))
                    if stoponerr:
                        sys.exit(-1)
                rv = fcntl.fcntl(fd, LOCK_MODES[mode][1], lockdata)
            else:
                rv = fcntl.fcntl(fd, LOCK_MODES[mode][1], lockdata)
    except IOError as e:
        logger.err("failed to lock %s" % str(e))
        if stoponerr:
            exit(-1)

    if mode == 'unlock':
        return
    glocks.append((offset, length))


def patterns(pattern):
    """ return requested io pattern
    """
    if pattern == 'one':
        return '\xff'
    elif pattern == 'zero':
        return '\x00'
    elif pattern == 'rand' or pattern == 'random':
        return 'TBD'
    else:
        return pattern


def post(fd, hold):
    """ cleanup after hold
    """
    logger.info("I/O completed, holding for %d seconds" % hold)
    time.sleep(hold)
    for lck in glocks:
        try:
            posix_lock(fd, 'unlock', lck[0], lck[1], None)
            logger.debug("unlock [offset=%d, len=%d]" % (lck[0], lck[1]))
        except IOError as e:
            logger.error("unlock fail [offset=%d, len=%d]" % (lck[0], lck[1])) 
            if stoponerr:
                exit(-1)
    os.close(fd)


def deleg():
    """ validates if delegation bestowed
    """
    return


def deleg_retrun():
    """ validate if delegation recalled
    """
    return



if __name__ == '__main__':
    """ main test
    """
    if len(sys.argv) == 1:
        usage()
        sys.exit(-1)
    # set default
    fp = None
    iosize = 512
    iopattern = '0xff'
    iocount = 1
    rw = 'noop'
    wait = 0
    hold = 0
    step = 0
    skip = 0
    lock= 'noop'
    direct = 1
    debug = 0
    stoponerr = 1
   
    try:
        opts, args = getopt.getopt(
                sys.argv[1:], 
                'h:', [
                          'help',
                          'path=', 
                          'rw=',
                          'iosize=',
                          'blocksize=',
                          'bs=',
                          'pattern=',
                          'count=', 
                          'wait=', 
                          'hold=', 
                          'lock=', 
                          'skip=', 
                          'step=', 
                          'direct=',
                          'debug=',
                          'stoponerr=',
                          ]
        )

    except getopt.GetoptError as e:
        # print help information and exit:
        sys.exit("Parameter Error: %s" % str(e))

    for o, a in opts:
        if o in ('--path'):
            fp = a  
        elif o in ('--rw'):
            if a in ('write', 'w', 'create', 'c', 'read', 'r'):
                rw = a
            else:
                exit("[arg err]: invalid value for --rw, " \
                        + "please use one from ['write', 'w', 'create', 'c', 'read', 'r']")
        elif o in ('--iosize', '--blocksize', '--bs'):
            iosize=convert_size(a)
        elif o in ('--pattern'):
            iopattern = patterns(a)
        elif o in ('--count'):
            iocount = int(a)
        elif o in ('--wait'):
            wait = int(a)
        elif o in ('--hold'):
            hold = int(a)
        elif o in ('--lock'):
            if a in ('exclusive', 'exclusive_blk', 'shared', 'unlock'):
                lock = a
            else:
                exit("[arg err]: invalid value for --lock, " \
                        + "please choose one from exclusive|exclusive_blk|shared|unlock")
        elif o in ('--skip'):
            skip = convert_size(a)
        elif o in ('--step'):
            step = convert_size(a)
        elif o in ('--debug'):
            if a in ('1', '0'):
                debug = int(a)
            else:
                exit("[arg err]: invalid value for --debug, " \
                        + "please choose one from ['1', '0']")
        elif o in ('--stoponerr'):
            if a in ('1', '0'):
                debug = int(a)
            else:
                exit("[arg err]: invalid value for --stoponerr, " \
                        + "please choose one from ['1', '0']")
        elif o in ('--direct'):
            if a in ('1', '0'):
                direct = int(a)
            else:
                exit("[arg err]: invalid value for --direct, " \
                        + "please use one from ['1', '0']")
        else:
            assert False, usage()
    if debug:
        logger.setLevel(logging.DEBUG)
    post(do_io(fp, rw, iopattern, iosize, iocount, skip, step, direct, lock, wait), hold)
    stats(fp, iosize, iocount)

