#! python sdd.py

import os
import sys
import time
import mmap
import getopt


def do_io(file_path, rw, pattern, io_size, count, skip, step, direct, wait):
    if rw == 'read' or rw == 'r':
        openmode = os.O_RDONLY
    elif rw == 'write' or rw == 'w':
        openmode = os.O_RDWR
    if direct == 1:
        openmode |= os.O_DIRECT

    # use mmap make it page aligned
    buf = mmap.mmap(-1, io_size)
    buf.write(pattern)

    try:
        fd = os.open(file_path, openmode)
        stop = (io_size + step) * count
        step += io_size
        print("dbg: [%d, %d %d]" %(skip, stop, step))
        for pos in xrange(skip, stop, step):
            os.lseek(fd, pos, os.SEEK_CUR)
            if rw == 'write' or rw == 'w':
                os.write(fd, buf)
            elif rw == 'read' or rw == 'r':
                buf = os.read(fd, io_size)
                print("dbg: %s" % buf)
            elif rw == 'noop':
                pass
            print("dbg: %s (offset=%d, len=%d)" % (rw, pos, io_size))
            time.sleep(wait)
    except IOError as e:
        print("EORR: Failed to perform DirectIO with error: %s" % str(e))

    return fd


def nt_lock(offset, length, mode):
    """ create NT lock
    """
    return 


def usage():
    print("SmartIO - A smart, lite IO tool")
    print("smartio.py <OPTIONS>")
    OPT = "\n"
    OPT += "OPTIONs:\n\n"
    OPT += "    --path   : Target file/block to be manipulated\n\n"
    OPT += "    --rw     : Write or read, accepts values: 'w', 'r', 'write', 'read' and 'null'\n\n"
    OPT += "    --iosize : Size of each IO to be performed\n\n"
    OPT += "    --count  : Number of IO to be performed\n\n"
    OPT += "    --skip   : The starting offset\n\n"
    OPT += "    --step   : The offset interval between each IO\n\n"
    OPT += "    --direct : Indicate if use direct IO, accepts '1' and '0'\n\n"
    OPT += "    --lock   : Indicate if create range lock before IO, accepts values 'exclusive', 'shared' and 'unlock'(verify on exclusive)\n\n"
    OPT += "    --wait   : Duration of wait in between each IO\n\n"
    OPT += "    --hold   : Duration to hold after the completion of IO\n\n\n\n"

    print(OPT)


def stats():
    """ summarize the performance stats
    """
    return  #TBD


def convert_size(raw):
   return int(raw) #TBD
     

def posix_lock(fd, lockmode, offset,length, data):
    """ posix locks
    """
    fh = self._filehandle
    mode = lock_mode
    data = self._data
    lockdata = struct.pack('hhllhh', self._LOCK_MODES[mode][1], \
            0, offset, length, 0, 0)

    if data:
        if mode == 'exclusive_io' or mode == 'exclusive_blk_io':
            rv = fcntl.fcntl(fh, self._LOCK_MODES[mode][2], lockdata)
            fh.seek(offset)
            # truncate extra content which exceeds end offest
            fh.write(data)
        elif mode == 'shared' or mode == 'unlock':
            # NOTE
            # the minimal size of kernel read is one page (4KB)
            # hence the read may failed if target bytes
            # which page was overlappped on other byte(s)
            # owned by other lockowners
            fh.seek(offset)
            readdata = fh.read(len(self._data))
            if readdata != data:
                sys.exit("ERROR: data verification failed. expect: %s | actual: %s" % (data, readdata))
        rv = fcntl.fcntl(fh, self._LOCK_MODES[mode][2], lockdata)
    else:
        rv = fcntl.fcntl(fh, self._LOCK_MODES[mode][2], lockdata)


def random_string(size=8, seed=None):
    """ generate a random string
    """
    :param size : length of target string to be generated
    :param seed : seed to be used for generating string
if __name__ == '__main__':
    """ main test
    """
    if len(sys.argv) == 1:
        usage()
        sys.exit(-1)
    # set default
    fp = None
    iosize = 512
    iopattern = '1' * iosize
    iocount = 1
    rw = 'read'
    wait = 0
    hold = 0
    step = 0
    skip = 0
    lock= 'shared'
    direct = 0
   
    try:
        opts, args = getopt.getopt(
                sys.argv[1:], 
                'h:', [
                          'help',
                          'path=', 
                          'rw=',
                          'iosize=',
                          'pattern=',
                          'count=', 
                          'wait=', 
                          'hold=', 
                          'lock=', 
                          'skip=', 
                          'step=', 
                          'direct=']
        )

    except getopt.GetoptError as e:
        # print help information and exit:
        sys.exit("Parameter Error: %s" % str(e))

    for o, a in opts:
        if o in ('--path'):
            fp = a  
        elif o in ('--rw'):
            rw = a
        elif o in ('--iosize'):
            iosize=convert_size(a)
        elif o in ('--pattern'):
            iopattern = get_pattern(a)
        elif o in ('--rw'):
            rw = a
        elif o in ('--count'):
            iocount = int(a)
        elif o in ('--wait'):
            wait = int(a)
        elif o in ('--hold'):
            hold = int(a)
        elif o in ('--lock'):
            lock = a
        elif o in ('--skip'):
            skip = convert_size(a)
        elif o in ('--step'):
            step = convert_size(a)
        elif o in ('--direct'):
            direct = int(a)
        else:
            assert False, usage()

    myfd = do_io(fp, rw, iopattern, iosize, iocount, skip, step, direct, wait)
    stats()
    if hold != 0:
        print("I/O completed, holding for %d seconds" % hold)
        time.sleep(hold)
    else:
        print("Done")
    os.close(myfd)

